#!/usr/bin/env bash
set -e

# Print usage info and abort
usage() {
    cat >&2 <<EOF
USAGE:
  longjobs                        # Print a list of running jobs
  longjobs -h                     # Show this message
  longjobs -p 4598 name           # Add a pid watch with a name
  longjobs -g nix-build nix-build # Add a pgrep watch
  longjobs -c                     # Clear all watches
  longjobs -o                     # Print with one-line output
  longjobs -a                     # Print raw accumulator output (under the hood stuff)
  longjobs -d 5                   # Run as daemon, refreshing every 5 seconds

Be sure to have a daemon running to produce the data. The other commands just read
out the latest finished results. If nobody's cooking, there's nothing to eat.
EOF
    exit 1
}

# Create directory if it doesn't exist
if [[ ! -d ~/.longjobs ]]; then
    mkdir ~/.longjobs
fi

# Set up new accumulator system if necessary
if [[ ! -e ~/.longjobs/acc ]]; then
    touch ~/.longjobs/acc.a
    ln -sf ~/.longjobs/acc.a ~/.longjobs/acc
    rm -f ~/.longjobs/accumulator
fi

# Set default options.
SHOULD_OUTPUT_WATCH=1
ONELINE_OUTPUT=0

determine_accumulator() {
    OLD_ACCUMULATOR=$(readlink -f ~/.longjobs/acc)
    if [[ "$(basename $OLD_ACCUMULATOR)" = "acc.a" ]]; then
        NEW_ACCUMULATOR="$HOME/.longjobs/acc.b"
    else
        NEW_ACCUMULATOR="$HOME/.longjobs/acc.a"
    fi
}

swap_accumulator() {
    ln -sf $NEW_ACCUMULATOR ~/.longjobs/acc
}

clear_accumulator() {
    echo -n '' > $NEW_ACCUMULATOR
}

# Function to add a single label to accumulator N times
accumulate() {
    label="$1"; shift
    count="$1"; shift
    while [[ $count -gt 0 ]]; do
        echo "$label" >> $NEW_ACCUMULATOR
        count=$(( count-1 ));
    done
}

# Remove all watchfiles.
clear_watches() {
    SHOULD_OUTPUT_WATCH=0
    rm -f ~/.longjobs/*.pid
    rm -f ~/.longjobs/*.pgrep
    echo "All watches cleared"
}

# Process PID watches
watch_pids() {
    if [[ -n $(find ~/.longjobs/ -name '*.pid') ]]; then
        for pidfile in ~/.longjobs/*.pid; do
            # echo "testing pidfile $pidfile" >&2
            label="$(basename $pidfile .pid)"
            pid=$(head -1 $pidfile | grep -o '[[:digit:]]\+' || true)
            if [[ -z "$pid" ]]; then
                continue
            fi
            if (ps "$pid" > /dev/null); then
                accumulate "$label" 1
            fi
        done
    fi
}

# Process pgrep watches
watch_pgreps() {
    if [[ -n $(find ~/.longjobs/ -name '*.pgrep') ]]; then
        for pgrepfile in ~/.longjobs/*.pgrep; do
            label="$(basename $pgrepfile .pgrep)"
            query="$(head -1 $pgrepfile || true)"
            if [[ -z "$query" ]]; then
                continue
            fi
            count=$(pgrep "$query" | wc -l);
            if [[ "$count" -ne "0" ]]; then
                accumulate "$label" $count
            fi
        done
    fi
}

accumulate_all() {
    determine_accumulator
    clear_accumulator

    watch_pids
    watch_pgreps

    swap_accumulator
}

add_pid() {
    SHOULD_OUTPUT_WATCH=0
    if [[ -z "$1" || -z "$2" ]]; then
        usage
    fi
    echo "$1" > ~/.longjobs/${2}.pid
}

add_pgrep() {
    SHOULD_OUTPUT_WATCH=0
    if [[ -z "$1" || -z "$2" ]]; then
        usage
    fi
    echo "$1" > ~/.longjobs/${2}.pgrep
}

produce_output() {
    # Print accumulated results
    determine_accumulator
    sort $OLD_ACCUMULATOR | uniq -c
}

oneline_output() {
    line=$(sed -e 's/^ *//' -e 's/^1 //' | tr '\n' ',' | sed -e 's/,$//' -e 's/,/, /g')
    if [[ -n "$line" ]]; then
        echo $line
    fi
}

print_accumulator() {
    SHOULD_OUTPUT_WATCH=0
    determine_accumulator
    cat $OLD_ACCUMULATOR
}

daemon_mode() {
    SHOULD_OUTPUT_WATCH=0
    sleep_time="$1"; shift;
    if [[ -z "$sleep_time" ]]; then
        sleep_time=5
    fi

    echo "Running in daemon mode"
    while :
    do
        accumulate_all
        sleep $sleep_time
    done
}

process_options() {
    while getopts ":hpgoacd" opt; do
        case $opt in
            h)
                usage;;
            p)
                add_pid "$2" "$3";
                shift; shift;;
            g)
                add_pgrep "$2" "$3";
                shift; shift;;
            o)
                ONELINE_OUTPUT=1;;
            a)
                print_accumulator;;
            c)
                clear_watches;;
            d)
                daemon_mode "$2";
                shift;;
            \?)
                usage;;
        esac
    done
}

main() {
    process_options "$@"
    if [[ "$SHOULD_OUTPUT_WATCH" -eq "1" ]]; then
        if [[ "$ONELINE_OUTPUT" -eq "1" ]]; then
            produce_output | oneline_output
        else
            produce_output
        fi
    fi
}

main "$@"
